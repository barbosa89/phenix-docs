(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{343:function(e,t,s){"use strict";s.r(t);var a=s(25),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"architecture"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#architecture"}},[e._v("#")]),e._v(" Architecture")]),e._v(" "),t("h2",{attrs:{id:"php-fpm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#php-fpm"}},[e._v("#")]),e._v(" PHP-FPM")]),e._v(" "),t("p",[e._v("There are several ways to execute a PHP script, the most popular way at the moment is PHP-FPM (FastCGI Process Manager), PHP-FPM is a server API (SAPI) for PHP that is designed to handle the execution of PHP scripts in a highly efficient, FPM has a main process that is responsible for receiving requests through proxied connections, for example from Nginx o Apache with the Event Multi-Processing module, this main process creates and destroys worker processes dynamically, this mechanism allows serving the traffic of a website, each worker bootstraps the application code, then compiles it, executes it and returns the response. FPM works very well, as developers we don't have to worry about memory leaks, it's just that performance is sacrificed a little due to the bootstraping, compilation and execution process.")]),e._v(" "),t("p",[e._v("On the other hand, there are flavors of PHP that allow you to keep the code in memory, such as Swoole, RoadRunner and recently FrankenPHP; Laravel with its Octane package implements Swoole and RoadRunner. The strategy of these flavors is to reduce the loading process by keeping the code in memory, although at this point the specter of memory leaks appears.")]),e._v(" "),t("h3",{attrs:{id:"server-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#server-api"}},[e._v("#")]),e._v(" Server API")]),e._v(" "),t("p",[e._v("Server APIs (SAPI) are the types of interface between PHP and the server, SAPIs handle communication between web servers and PHP scripts; some historically known: CGI, Apache (mod_php), FastCGI (PHP-FPM), Embedded, CLI. Phenix is executed in the CLI (Command Line Interfaz) as a long-running process, let's see some advantages of this SAPI.")]),e._v(" "),t("h2",{attrs:{id:"cli-sapi"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cli-sapi"}},[e._v("#")]),e._v(" CLI SAPI")]),e._v(" "),t("p",[e._v("Scripting languages like Python and JavaScript with Node run their servers in the CLI, if you're wondering why, it's simply that this offers many advantages:")]),e._v(" "),t("ul",[t("li",[e._v("The interface was designed for command-line execution, making it suitable for scripting and automation tasks.")]),e._v(" "),t("li",[e._v("Provides direct access to the PHP interpreter for running scripts without the need for a web server.")]),e._v(" "),t("li",[e._v("Allows for easy debugging and script testing from the command line.")]),e._v(" "),t("li",[e._v("Script code is kept in memory.")]),e._v(" "),t("li",[e._v("PHP can now run your own production-ready server.")])]),e._v(" "),t("p",[e._v("The Amphp ecosystem leverages the CLI and Fibers to enable asynchronous code writing, concurrent applications, and efficient resource usage. This approach allows to handle a large number of concurrent fibers without wasting CPU resources.")]),e._v(" "),t("h2",{attrs:{id:"php-is-weird"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#php-is-weird"}},[e._v("#")]),e._v(" PHP is weird")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.youtube.com/watch?v=ECuD_dGvxyY",target:"_blank",rel:"noopener noreferrer"}},[e._v("Chris Fidao published a video"),t("OutboundLink")],1),e._v(" in which he explains that the HTTP protocol is naturally stateless, he demonstrated how other languages maintain a state in consecutive requests, effectively PHP like the HTTP protocol remains stateless, but the Amphp server running in the CLI, it allows us to maintain a state like in other programming languages. Is this good or bad for PHP? Obviously good, PHP now has all the flavors and is at the forefront of the most modern languages.")]),e._v(" "),t("div",{staticClass:"language-php extra-class"},[t("pre",{pre:!0,attrs:{class:"language-php"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name-definition class-name"}},[e._v("CounterController")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("extends")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Controller")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("protected")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("static")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword type-declaration"}},[e._v("int")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$counter")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function-definition function"}},[e._v("index")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name return-type"}},[e._v("Response")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword static-context"}},[e._v("self")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),t("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$counter")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("response")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("->")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("json")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n            "),t("span",{pre:!0,attrs:{class:"token string single-quoted-string"}},[e._v("'counter'")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword static-context"}},[e._v("self")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),t("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$counter")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),t("p",[e._v("Send requests to this controller and watch the counter increment with each request received.")]),e._v(" "),t("h3",{attrs:{id:"coroutine-architecture"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#coroutine-architecture"}},[e._v("#")]),e._v(" Coroutine architecture")]),e._v(" "),t("p",[e._v("Amphp uses a fiber-based coroutine architecture to implement asynchronous programming in PHP. Fibers are a lightweight alternative to threads that allow you to write concurrent and parallel code without the overhead of context switching. Amphp uses a single event loop to manage all of the fibers in an application. The event loop is responsible for scheduling fibers, handling I/O events, and managing timers. When a fiber needs to be executed, it is added to the event loop's queue. The event loop then executes the fibers one at a time, in the order that they were added to the queue.")]),e._v(" "),t("p",[e._v("If a fiber needs to wait for something, such as a database query or a network response, it is suspended from the event loop. The event loop then continues executing other fibers until the suspended fiber is ready to resume. When a fiber is resumed, it is added to the end of the event loop's queue. This ensures that all fibers are given an equal amount of time to execute. Amphp also supports cooperative multitasking. This means that a fiber can yield control to another fiber without having to wait for the event loop to schedule it.")]),e._v(" "),t("h2",{attrs:{id:"request-lifecycle"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#request-lifecycle"}},[e._v("#")]),e._v(" Request lifecycle")]),e._v(" "),t("p",[e._v("The entry point for the application is the "),t("code",[e._v("public/index.php")]),e._v(" file. In this file, the application is loaded from the "),t("code",[e._v("bootstrap/app.php")]),e._v(" file, and the server is executed as a long-running process and it is kept in memory, and it won't be bootstrapped for each incoming request.")]),e._v(" "),t("p",[e._v("Within "),t("code",[e._v("public/index.php")]),e._v(", the Composer autoloader file is loaded to manage dependencies.")]),e._v(" "),t("h2",{attrs:{id:"service-providers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service-providers"}},[e._v("#")]),e._v(" Service providers")]),e._v(" "),t("p",[e._v("Service providers are responsible for loading different components into the framework such as databases, file system and routes. Phenix uses the "),t("a",{attrs:{href:"https://container.thephpleague.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("container"),t("OutboundLink")],1),e._v(" created by PHP League, it is lightweight and powerful. You can look at the service providers that are loaded by default in "),t("code",[e._v("config/app.php")]),e._v(" file. You can find more information in the "),t("RouterLink",{attrs:{to:"/guide/providers.html"}},[e._v("service providers")]),e._v(" section.")],1),e._v(" "),t("h2",{attrs:{id:"routes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#routes"}},[e._v("#")]),e._v(" Routes")]),e._v(" "),t("p",[e._v("The routes are loaded by the "),t("code",[e._v("Phenix\\Providers\\RouteServiceProvider")]),e._v(" from the "),t("code",[e._v("routes/api.php")]),e._v(" file, this is where you can define and organize your routes. You can find more information in the "),t("RouterLink",{attrs:{to:"/guide/routing.html"}},[e._v("routes")]),e._v(" section.")],1)])}),[],!1,null,null,null);t.default=r.exports}}]);